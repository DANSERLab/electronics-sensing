import ddf.minim.*;
import ddf.minim.analysis.*;
import ddf.minim.effects.*;
import ddf.minim.signals.*;
import ddf.minim.spi.*;
import ddf.minim.ugens.*;

FFT fft;
float[] dataF;
int fs = 250;
int L = 256;
float T = 1.0f/ fs;

PImage logo;
int logoS = 200;
PFont p1, p2, mbFont;

Canvas cc;

public void setup() {
  frameRate(30);
  size(1000, 1000);
  background(bgColor);
  noStroke();

  p1 = createFont("Arial", 20); 
  mbFont = createFont("Arial", 12);

  dataF = new float[256];
  fft = new FFT(L, fs);

  mainPanel = new MainPanel(this);
}


void draw() {
  drawUI();
}

void drawUI() {
  mainPanel.draw();
}

void startRecording() {
  RECORDING = true;
  fileOutput.print("#");
  for (int i = 1; i < numAFEs+1; i++) {
    for (int j = 1; j < numChannels+1; j++) {
      fileOutput.print("AFE" + str(i) + "_" + str(j) + "\t");
    }
  }
  fileOutput.println();
}

void stopRecording() {
  fileOutput.flush();
  fileOutput.close();
  RECORDING = false;
}

void injectFFT() {
  for (int i = 0; i < L; i++) {
    dataF[i] = 0.7*sin(2*PI*50*i*T) + sin(2*PI*70*i*T);
  }
  fft.forward(dataF);
  for (int i = 0; i < fft.specSize(); i++)
  {
    fft.setBand(i, fft.getBand(i)/fft.timeSize());
  }
  for (int i = 1; i < fft.specSize() - 1; i++) {
    fft.setBand(i, fft.getBand(i) * 2);
  }
  for (int i = 0; i < fft.specSize(); i++) {
    println(i, fft.getBand(i));
    line( i*2, height, i*2, height - fft.getBand(i)*L);
  }
}

void populateFFTBuffer(){
  for(int i =0; i < dataF.length; i++){
    
  }
}